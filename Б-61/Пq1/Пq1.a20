 ;Пq1 - первая версия - в стандарте Б-61
 ;основана на СП-0027 из библиотеки ИС-2
 ;используется 2->10, основанная на СП-0010 той же библиотеки, переписанная под стандарты Б-61
 ;
 ;Описание см. "Библиотека Б-61", ИТЭФ, 1965, (МИИТ, 1970) стр.61-62
 ;
 ;также см. Гутер Р.С., Арлазаров В.Л., Усков А.В.
 ;"Практика программирования", М.: Наука, 1965. - стр. 127-128,
 ;где в т.ч. приведен пример выдачи
 ;
 ;обращение:
 ; Я:   пв	Я+2,	Пq1,	Ω
 ; Я+1: k l1 l2	a1,	S+q,	an
 ;
 ;программа с информацией. 
 ;Программа берет числа из ячеек a1,a2,...,an,
 ;переводит их из двоичной системы в десятичную,
 ;используя "2->10" как подпрограмму, 
 ;заносит их на буфер и в зависимости от S
 ;выпечатывает эти числа немедленно или нет.
 ;S=4000 означает "Салют", т.е. после занесения 
 ;на буфер всё накопленное к этому моменту на буфере
 ;(в том числе и занесенное раньше) напечатается
 ;и произойдет очистка буфера.
 ;Если S=0, немедленной печати не будет (если только
 ;не накопится на буфере слишком много материала).
 ;При переполнении буфера произойдет автоматический
 ;"салют" и очистка буфера, что может случиться и 
 ;в середине переноса материала на буфер. Тогда
 ;остаток при S=4000 будет пропечатан немедленно
 ;по окончании занесения, а при S=0 останется на буфере 
 ;в ожидании дальнейшего.
 ;В зависимости от значения q (0=<q=<777oct)
 ;указанный массив чисел выпечатывается 
 ;с абзацами или без них:
 ;если q=0, то перед массивом чисел 
 ;и внутри него абзацев нет;
 ;если q<>0, то массив печатается группами 
 ;по q чисел. Перед каждой группой дается абзац
 ;и печатается адрес первой ячейки группы.
 ;Печать адресов блокируется нажатием
 ;36dec-го разряда ДЗУ-2.
 ;Блокировка работы программы осуществляется
 ;как в программе ПП-1.
 ;
 ;число k l1 l2 в коде ячейки информации
 ;используется для блокировки печати.
 ;здесь k означает одну из восьмеричных цифр 1,2 или 3,
 ;которую мы будем считать номером ДЗУ, а l1 l2 - 
 ;двузначное восьмеричное число от 01 до 54,
 ;означающее номер разряда в этом ДЗУ.
 ;нажатие соответствующей клавиши блокирует
 ;работу программы печати, и эта программа
 ;передает управление сразу ячейке Я+2.
 ;
 ;NB! пока реализованы только обработка a1 и an
 ;(если a1>=an, напечатается только a1)
 ;Используются R1,R2,R3
 ;Л.Ядренников 22.05.2022
 ;
;Программа Пq1
	.АДРЕС 0420
	.СТАРТ 0420
 ;Считывание ячеек из программы с информацией разобрано в книге
 ;Гутер, Арлазаров, Усков "Практика программирования", 1965, стр.158
 ;надо только помнить, что в конспиративных целях в той книге
 ;переходы осуществляются по III адресу
 ;
Пq1_:	или	0 Ω конец_Пq1		;в IIa Ω находится адрес ячейки, следующей за информационной. 
	ра	(0) 0 предконец_Пq1
	см	{0vF=R1} Ω Q
Q:	.ПАМ1		;{0 V {Я+1}=R1	;R1=инф ячейка
	сдса	64 R1 R2	;R2= {k.l1.l2} αМОЗУ S+q (без модификации)
	сдса	114 R1 R1	;R1= S+q ωМОЗУ 0
	и	{0.F.0} R1 R1	;R1= 0 ωМОЗУ 0 для корректных проверок командой ВМ
	рс    	0 R2 update_ra	;РА:=αМОЗУ, в update_ra заслать 0 52 0 0 0, т.е. команду РА:=0000
				;сейчас R1=0 00 0 ωМОЗУ 0
				;       R2=0 00 {k.l1.l2} αМОЗУ S+q
call2>10:
 ;адрес исходной ячейки записан в РА и д.б. переписан в αпеч; ответ в γпеч; 2->10 портит R5,R10
	или	0 (0) αпеч
	пв	*+1 биб2>10 Ω
	ра	(0001) 0000 next_ra  ;очищаем РА и в next_ra пишем РА=РА+1
	                        ;
store_digit:
	п	γпеч 0000 R2	;<x>10->R2 или R3	;формируемая, см. *+1 и next_ra-1
	н	{0.0.1} store_digit store_digit	;подготовить следующую цифру к записи в др.регистр (R2 после R3, R3 после R2)
	и	store_digit {0.0.1} oddeven	; oddeven=0 для текущей в R3 и =1 для текущей R2
	вм	proto50 oddeven print_cmd	;сформировали команду записи: для текущей R2 запись от R2 до R2, для R3 - от R2 до R3
update_ra:
	ра	0000 0000 0000  ;формируемая (см. call2>10 -1 и *+5)	;Aмзу=РА
	вм	R1 next_ra 0000	;ω=1 если сейчас перекодировали число по адресу ωМОЗУ
	пе	0000 print_cmd 0000	;в этом случае сразу печатаем
	и	{0.0.1} store_digit oddeven	;ω=1 oddeven=0 для текущей в R3 и ω=0 oddeven=1 для текущей R2
	пу	0000 next_ra 0000	;если текущая R2, без записи на буфер перекодируем след число 
	ра	(0002) (0000) update_ra	;A'мзу=Амзу+2  ;сформировали команду обновления РА новым Амзу
	пм	0774 *+3 (0000)	;Уход при Амзу<0774 ;если текущая пара (пред. и данная) будут последними на буфере, не уходить
	ра	0000 (0000) update_ra	;сформировали команду обновления РА нулевым Амзу
	н	{0200.0.0} print_cmd print_cmd	
	н	{0200.0.0} print_cmd print_cmd	;если текущая пара (пред. и данная) не последние, уст.8 разряд УЧ в print_cmd в 1 (накапливать на буфере)
print_cmd:
	.ПАМ1	;ма	3100 (0000) R3	;формируемая, см. update_ra -1: запись очередной пары на буфер
	мб	R2 0000 0000
	пб	write_to_r2 *+1 store_digit	;след цифра пойдет в R2   	;здесь могла стоять просто пересылка!
next_ra:  
	ра	0000 0000 0000  ;формируемая, РА=РА+1 (см.call2>10 +2)	;αT+1->РА
	пу	0000 call2>10 0000  ;переход на след число, если сейчас не записывали число по адресу ωМОЗУ
предконец_Пq1:	.ПАМ1
конец_Пq1:	.ПАМ1
 ;
 ;константы и шаблоны команд Пq1
proto50:
	ма	3100 (0000) R3
write_to_r2:
	п	γпеч 0000 R2
{0200.0.0}:
	0 00 0200 0000 0000
{0vF=R1}:
	или	0 7777 R1
oddeven:	.ПАМ1

	.ВСТАВИТЬ "../2-10/2-10_shurabura.a20"  ;программа 2-10 (вставлена для автономного тестирования)

  	.НЕПЕЧАТЬ
	.ВСТАВИТЬ "../b61.inc"                  ;заголовки
	.ВСТАВИТЬ "../../b61_const.inc"
	.ФИНИШ 0420
